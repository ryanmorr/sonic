{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","sonic.min.js","src/sonic.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","sonic","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","filter","el","filters","_filter","pseudos","name","param","tokenize","selectorString","split","splitRe","reduce","tokens","selector","_ret","combinators","push","v","replace","pseudoRe","all","_typeof","matches","matchesFn","find","root","query","arguments","undefined","doc","results","groups","trim","groupRe","context","shift","_loop","token","combinator","nodes","forEach","indexOf","sort","b","compareDocumentPosition","Object","defineProperty","value","Symbol","iterator","obj","constructor","document","documentElement","fn"," ","elements","querySelectorAll","len",">","parentNode","+","nextElementSibling","~"],"mappings":"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","file":"sonic.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*! sonic v0.2.0 | https://github.com/ryanmorr/sonic */\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.sonic = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nexports.matches = matches;\nexports.find = find;\nexports.query = query;\n/**\r\n * Common variables\r\n */\nvar doc = window.document;\nvar documentElement = doc.documentElement;\n\n/**\r\n * Parsing regular expressions\r\n */\nvar splitRe = /\\s*(>|\\+(?!\\d)|~(?!=)|\\s)\\s*/;\nvar pseudoRe = /:([\\w-]+)(?:\\(([^)]*)\\))?/g;\nvar groupRe = /\\s*,\\s*/;\n\n/**\r\n * Feature test for the browser's implementation\r\n * of `matches`\r\n */\nvar matchesFn = ['matches', 'matchesSelector', 'webkitMatchesSelector', 'mozMatchesSelector', 'oMatchesSelector', 'msMatchesSelector'].reduce(function (fn, name) {\n    if (fn) {\n        return fn;\n    }\n    return name in documentElement ? name : fn;\n}, null);\n\n/**\r\n * Map CSS selector combinators to a function\r\n * capable of finding the relative elements and\r\n * filtering them based on the provided token\r\n */\nvar combinators = {\n\n    /**\r\n     * Find all descendant elements of the\r\n     * context matching the token\r\n     *\r\n     * @param {Element} context\r\n     * @param {Object} token\r\n     * @param {Array} results\r\n     * @return {Array}\r\n     * @api private\r\n     */\n    ' ': function descendantCombinator(context, token, results) {\n        var elements = context.querySelectorAll(token.selector);\n        for (var i = 0, len = elements.length, el; i < len; i++) {\n            el = elements[i];\n            if (filter(el, token.filters)) {\n                results.push(el);\n            }\n        }\n        return results;\n    },\n\n    /**\r\n     * Find all child elements of the\r\n     * context matching the token\r\n     *\r\n     * @param {Element} context\r\n     * @param {Object} token\r\n     * @param {Array} results\r\n     * @return {Array}\r\n     * @api private\r\n     */\n    '>': function childCombinator(context, token, results) {\n        var elements = context.querySelectorAll(token.selector);\n        for (var i = 0, len = elements.length, el; i < len; i++) {\n            el = elements[i];\n            if (el.parentNode === context && filter(el, token.filters)) {\n                results.push(el);\n            }\n        }\n        return results;\n    },\n\n    /**\r\n     * Find all adjacent sibling elements of the\r\n     * context matching the token\r\n     *\r\n     * @param {Element} context\r\n     * @param {Object} token\r\n     * @param {Array} results\r\n     * @return {Array}\r\n     * @api private\r\n     */\n    '+': function adjacentSiblingCombinator(context, token, results) {\n        var el = context.nextElementSibling;\n        if (el && matches(el, token.selector) && filter(el, token.filters)) {\n            results.push(el);\n        }\n        return results;\n    },\n\n    /**\r\n     * Find all general sibling element of the\r\n     * context matching the token\r\n     *\r\n     * @param {Element} context\r\n     * @param {Object} token\r\n     * @param {Array} results\r\n     * @return {Array}\r\n     * @api private\r\n     */\n    '~': function generalSiblingCombinator(context, token, results) {\n        var el = context.nextElementSibling;\n        while (el) {\n            if (matches(el, token.selector) && filter(el, token.filters)) {\n                results.push(el);\n            }\n            el = el.nextElementSibling;\n        }\n        return results;\n    }\n};\n\n/**\r\n * Export pseudo-class map for custom filters\r\n */\nvar pseudos = exports.pseudos = {};\n\n/**\r\n * Run all the custom filters against an\r\n * element to determine if it is a match\r\n *\r\n * @param {Element} el\r\n * @param {Array} filters\r\n * @return {Boolean}\r\n * @api private\r\n */\nfunction filter(el, filters) {\n    var i = filters.length;\n    while (i--) {\n        var _filter = filters[i];\n        if (!pseudos[_filter.name](el, _filter.param)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\r\n * Convert a selector string into an\r\n * array of tokens\r\n *\r\n * @param {String} selectorString\r\n * @return {Array}\r\n * @api private\r\n */\nfunction tokenize(selectorString) {\n    return selectorString.split(splitRe).reduce(function (tokens, selector) {\n        if (selector) {\n            var _ret = function () {\n                if (selector in combinators) {\n                    tokens.push(selector);\n                    return {\n                        v: tokens\n                    };\n                }\n                var filters = [];\n                selector = selector.replace(pseudoRe, function (all, name, param) {\n                    if (name in pseudos) {\n                        filters.push({ name: name, param: param });\n                        return '';\n                    }\n                    return all;\n                });\n                selector = selector === '' ? '*' : selector;\n                tokens.push({ selector: selector, filters: filters });\n            }();\n\n            if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n        }\n        return tokens;\n    }, []);\n}\n\n/**\r\n * Does an element match a CSS selector string\r\n *\r\n * @param {Element} el\r\n * @param {String} selector\r\n * @return {Boolean}\r\n * @api public\r\n */\nfunction matches(el, selector) {\n    return el[matchesFn](selector);\n}\n\n/**\r\n * Find a single element based on a CSS\r\n * selector string\r\n *\r\n * @param {String} selector\r\n * @param {Element|String} root\r\n * @return {Element}\r\n * @api public\r\n */\nfunction find(selector, root) {\n    return query(selector, root)[0] || null;\n}\n\n/**\r\n * Query for all elements matching a\r\n * CSS selector string\r\n *\r\n * @param {String} selector\r\n * @param {Element|String} root\r\n * @return {Element}\r\n * @api public\r\n */\nfunction query(selector) {\n    var root = arguments.length <= 1 || arguments[1] === undefined ? doc : arguments[1];\n\n    if (typeof root === 'string') {\n        root = find(root);\n    }\n    var results = [];\n    var groups = selector.trim().split(groupRe);\n    while (groups.length) {\n        var context = [root];\n        var tokens = tokenize(groups.shift());\n\n        var _loop = function _loop() {\n            var token = tokens.shift(),\n                combinator = combinators[' '];\n            if (token in combinators) {\n                combinator = combinators[token];\n                token = tokens.shift();\n            }\n            context = context.reduce(function (nodes, el) {\n                return combinator(el, token, nodes);\n            }, []);\n        };\n\n        while (tokens.length && context.length) {\n            _loop();\n        }\n        context.forEach(function (el) {\n            if (results.indexOf(el) === -1) {\n                results.push(el);\n            }\n        });\n    }\n    return results.sort(function (a, b) {\n        return 3 - (a.compareDocumentPosition(b) & 6);\n    });\n}\n\n/**\r\n * Declare and export `sonic` namespace\r\n */\nvar sonic = { matches: matches, find: find, query: query, pseudos: pseudos };\nexports.default = sonic;\n\n},{}]},{},[1])(1)\n});\n\n","/**\r\n * Common variables\r\n */\r\nconst doc = window.document;\r\nconst documentElement = doc.documentElement;\r\n\r\n/**\r\n * Parsing regular expressions\r\n */\r\nconst splitRe = /\\s*(>|\\+(?!\\d)|~(?!=)|\\s)\\s*/;\r\nconst pseudoRe = /:([\\w-]+)(?:\\(([^)]*)\\))?/g;\r\nconst groupRe = /\\s*,\\s*/;\r\n\r\n/**\r\n * Feature test for the browser's implementation\r\n * of `matches`\r\n */\r\nconst matchesFn = [\r\n    'matches',\r\n    'matchesSelector',\r\n    'webkitMatchesSelector',\r\n    'mozMatchesSelector',\r\n    'oMatchesSelector',\r\n    'msMatchesSelector'\r\n].reduce((fn, name) => {\r\n    if (fn) {\r\n        return fn;\r\n    }\r\n    return name in documentElement ? name : fn;\r\n}, null);\r\n\r\n/**\r\n * Map CSS selector combinators to a function\r\n * capable of finding the relative elements and\r\n * filtering them based on the provided token\r\n */\r\nconst combinators = {\r\n\r\n    /**\r\n     * Find all descendant elements of the\r\n     * context matching the token\r\n     *\r\n     * @param {Element} context\r\n     * @param {Object} token\r\n     * @param {Array} results\r\n     * @return {Array}\r\n     * @api private\r\n     */\r\n    ' ': function descendantCombinator(context, token, results) {\r\n        const elements = context.querySelectorAll(token.selector);\r\n        for (let i = 0, len = elements.length, el; i < len; i++) {\r\n            el = elements[i];\r\n            if (filter(el, token.filters)) {\r\n                results.push(el);\r\n            }\r\n        }\r\n        return results;\r\n    },\r\n\r\n    /**\r\n     * Find all child elements of the\r\n     * context matching the token\r\n     *\r\n     * @param {Element} context\r\n     * @param {Object} token\r\n     * @param {Array} results\r\n     * @return {Array}\r\n     * @api private\r\n     */\r\n    '>': function childCombinator(context, token, results) {\r\n        const elements = context.querySelectorAll(token.selector);\r\n        for (let i = 0, len = elements.length, el; i < len; i++) {\r\n            el = elements[i];\r\n            if (el.parentNode === context && filter(el, token.filters)) {\r\n                results.push(el);\r\n            }\r\n        }\r\n        return results;\r\n    },\r\n\r\n    /**\r\n     * Find all adjacent sibling elements of the\r\n     * context matching the token\r\n     *\r\n     * @param {Element} context\r\n     * @param {Object} token\r\n     * @param {Array} results\r\n     * @return {Array}\r\n     * @api private\r\n     */\r\n    '+': function adjacentSiblingCombinator(context, token, results) {\r\n        const el = context.nextElementSibling;\r\n        if (el && matches(el, token.selector) && filter(el, token.filters)) {\r\n            results.push(el);\r\n        }\r\n        return results;\r\n    },\r\n\r\n    /**\r\n     * Find all general sibling element of the\r\n     * context matching the token\r\n     *\r\n     * @param {Element} context\r\n     * @param {Object} token\r\n     * @param {Array} results\r\n     * @return {Array}\r\n     * @api private\r\n     */\r\n    '~': function generalSiblingCombinator(context, token, results) {\r\n        let el = context.nextElementSibling;\r\n        while (el) {\r\n            if (matches(el, token.selector) && filter(el, token.filters)) {\r\n                results.push(el);\r\n            }\r\n            el = el.nextElementSibling;\r\n        }\r\n        return results;\r\n    }\r\n};\r\n\r\n/**\r\n * Export pseudo-class map for custom filters\r\n */\r\nexport const pseudos = {};\r\n\r\n/**\r\n * Run all the custom filters against an\r\n * element to determine if it is a match\r\n *\r\n * @param {Element} el\r\n * @param {Array} filters\r\n * @return {Boolean}\r\n * @api private\r\n */\r\nfunction filter(el, filters) {\r\n    let i = filters.length;\r\n    while (i--) {\r\n        const filter = filters[i];\r\n        if (!pseudos[filter.name](el, filter.param)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n/**\r\n * Convert a selector string into an\r\n * array of tokens\r\n *\r\n * @param {String} selectorString\r\n * @return {Array}\r\n * @api private\r\n */\r\nfunction tokenize(selectorString) {\r\n    return selectorString.split(splitRe).reduce((tokens, selector) => {\r\n        if (selector) {\r\n            if (selector in combinators) {\r\n                tokens.push(selector);\r\n                return tokens;\r\n            }\r\n            const filters = [];\r\n            selector = selector.replace(pseudoRe, (all, name, param) => {\r\n                if (name in pseudos) {\r\n                    filters.push({name, param});\r\n                    return '';\r\n                }\r\n                return all;\r\n            });\r\n            selector = selector === '' ? '*' : selector;\r\n            tokens.push({selector, filters});\r\n        }\r\n        return tokens;\r\n    }, []);\r\n}\r\n\r\n/**\r\n * Does an element match a CSS selector string\r\n *\r\n * @param {Element} el\r\n * @param {String} selector\r\n * @return {Boolean}\r\n * @api public\r\n */\r\nexport function matches(el, selector) {\r\n    return el[matchesFn](selector);\r\n}\r\n\r\n/**\r\n * Find a single element based on a CSS\r\n * selector string\r\n *\r\n * @param {String} selector\r\n * @param {Element|String} root\r\n * @return {Element}\r\n * @api public\r\n */\r\nexport function find(selector, root) {\r\n    return query(selector, root)[0] || null;\r\n}\r\n\r\n/**\r\n * Query for all elements matching a\r\n * CSS selector string\r\n *\r\n * @param {String} selector\r\n * @param {Element|String} root\r\n * @return {Element}\r\n * @api public\r\n */\r\nexport function query(selector, root = doc) {\r\n    if (typeof root === 'string') {\r\n        root = find(root);\r\n    }\r\n    const results = [];\r\n    const groups = selector.trim().split(groupRe);\r\n    while (groups.length) {\r\n        let context = [root];\r\n        const tokens = tokenize(groups.shift());\r\n        while (tokens.length && context.length) {\r\n            let token = tokens.shift(), combinator = combinators[' '];\r\n            if (token in combinators) {\r\n                combinator = combinators[token];\r\n                token = tokens.shift();\r\n            }\r\n            context = context.reduce((nodes, el) => combinator(el, token, nodes), []);\r\n        }\r\n        context.forEach((el) => {\r\n            if (results.indexOf(el) === -1) {\r\n                results.push(el);\r\n            }\r\n        });\r\n    }\r\n    return results.sort((a, b) => 3 - (a.compareDocumentPosition(b) & 6));\r\n}\r\n\r\n/**\r\n * Declare and export `sonic` namespace\r\n */\r\nconst sonic = {matches, find, query, pseudos};\r\nexport default sonic;\r\n"],"sourceRoot":"/source/"}