{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/sonic.js"],"names":["f","exports","module","define","amd","window","global","self","this","sonic","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","el","selector","token","getToken","matches","filter","filters","doc","document","documentElement","arrayFilter","splitRe","pseudoRe","groupRe","matchesFn","reduce","fn","name","combinators"," ","context","results","concat","querySelectorAll",">","parentNode","+","nextElementSibling","push","~","pseudos","Object","create","_filter","param","replace","all","find","root","query","arguments","undefined","groups","trim","split","tokens","shift","_loop","combinator","nodes","forEach","indexOf","sort","b","compareDocumentPosition"],"mappings":"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","file":"sonic.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/**\r\n * Common variables\r\n */\r\nconst doc = window.document;\r\nconst documentElement = doc.documentElement;\r\nconst arrayFilter = [].filter;\r\n\r\n/**\r\n * Parsing regular expressions\r\n */\r\nconst splitRe = /\\s*(>|\\+(?!\\d)|~(?!=)|\\s)\\s*/;\r\nconst pseudoRe = /:([\\w-]+)(?:\\(([^)]*)\\))?/g;\r\nconst groupRe = /\\s*,\\s*/;\r\n\r\n/**\r\n * Feature test for the browser's implementation\r\n * of `matches`\r\n */\r\nconst matchesFn = [\r\n    'matches',\r\n    'webkitMatchesSelector',\r\n    'msMatchesSelector'\r\n].reduce((fn, name) => {\r\n    if (fn) {\r\n        return fn;\r\n    }\r\n    return name in documentElement ? name : fn;\r\n}, null);\r\n\r\n/**\r\n * Map CSS selector combinators to a function\r\n * capable of finding the relative elements and\r\n * filtering them based on the provided token\r\n */\r\nconst combinators = {\r\n\r\n    /**\r\n     * Find all descendant elements of the\r\n     * context matching the token\r\n     *\r\n     * @param {Element} context\r\n     * @param {Object} token\r\n     * @param {String} token.selector\r\n     * @param {Array} token.filters\r\n     * @param {Array} results\r\n     * @return {Array}\r\n     * @api private\r\n     */\r\n    ' ': (context, token, results) => {\r\n        return results.concat(arrayFilter.call(context.querySelectorAll(token.selector), (el) => {\r\n            return filter(el, token.filters);\r\n        }));\r\n    },\r\n\r\n    /**\r\n     * Find all child elements of the\r\n     * context matching the token\r\n     *\r\n     * @param {Element} context\r\n     * @param {Object} token\r\n     * @param {String} token.selector\r\n     * @param {Array} token.filters\r\n     * @param {Array} results\r\n     * @return {Array}\r\n     * @api private\r\n     */\r\n    '>': (context, token, results) => {\r\n        return results.concat(arrayFilter.call(context.querySelectorAll(token.selector), (el) => {\r\n            return el.parentNode === context && filter(el, token.filters);\r\n        }));\r\n    },\r\n\r\n    /**\r\n     * Find all adjacent sibling elements of the\r\n     * context matching the token\r\n     *\r\n     * @param {Element} context\r\n     * @param {Object} token\r\n     * @param {String} token.selector\r\n     * @param {Array} token.filters\r\n     * @param {Array} results\r\n     * @return {Array}\r\n     * @api private\r\n     */\r\n    '+': (context, token, results) => {\r\n        const el = context.nextElementSibling;\r\n        if (el && matches(el, token.selector) && filter(el, token.filters)) {\r\n            results.push(el);\r\n        }\r\n        return results;\r\n    },\r\n\r\n    /**\r\n     * Find all general sibling elements of the\r\n     * context matching the token\r\n     *\r\n     * @param {Element} context\r\n     * @param {Object} token\r\n     * @param {String} token.selector\r\n     * @param {Array} token.filters\r\n     * @param {Array} results\r\n     * @return {Array}\r\n     * @api private\r\n     */\r\n    '~': (context, token, results) => {\r\n        let el = context.nextElementSibling;\r\n        while (el) {\r\n            if (matches(el, token.selector) && filter(el, token.filters)) {\r\n                results.push(el);\r\n            }\r\n            el = el.nextElementSibling;\r\n        }\r\n        return results;\r\n    }\r\n};\r\n\r\n/**\r\n * Export pseudo-class map for custom filters\r\n */\r\nexport const pseudos = Object.create(null);\r\n\r\n/**\r\n * Does an element match a CSS selector string\r\n *\r\n * @param {Element} el\r\n * @param {String} selector\r\n * @return {Boolean}\r\n * @api private\r\n */\r\nfunction matches(el, selector) {\r\n    return el[matchesFn](selector);\r\n}\r\n\r\n/**\r\n * Test an element against the custom\r\n * pseudo-classes (if any) to determine if it\r\n * is a match\r\n *\r\n * @param {Element} el\r\n * @param {Array} filters\r\n * @return {Boolean}\r\n * @api private\r\n */\r\nfunction filter(el, filters) {\r\n    let i = filters.length;\r\n    while (i--) {\r\n        const filter = filters[i];\r\n        if (!pseudos[filter.name](el, filter.param)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n/**\r\n * Convert a simple selector into a token\r\n *\r\n * @param {String} selector\r\n * @return {Object}\r\n * @api private\r\n */\r\nfunction getToken(selector) {\r\n    const filters = [];\r\n    selector = selector.replace(pseudoRe, (all, name, param) => {\r\n        if (name in pseudos) {\r\n            filters.push({name, param});\r\n            return '';\r\n        }\r\n        return all;\r\n    });\r\n    selector = selector === '' ? '*' : selector;\r\n    return {selector, filters};\r\n}\r\n\r\n/**\r\n * Convert a selector string into an\r\n * array of tokens\r\n *\r\n * @param {String} selectorString\r\n * @return {Array}\r\n * @api private\r\n */\r\nfunction tokenize(selectorString) {\r\n    return selectorString.split(splitRe).reduce((tokens, selector) => {\r\n        if (selector) {\r\n            if (selector in combinators) {\r\n                tokens.push(selector);\r\n                return tokens;\r\n            }\r\n            tokens.push(getToken(selector));\r\n        }\r\n        return tokens;\r\n    }, []);\r\n}\r\n\r\n/**\r\n * Does an element match a CSS selector string\r\n * including custom pseudo-classes\r\n *\r\n * @param {Element} el\r\n * @param {String} selector\r\n * @return {Boolean}\r\n * @api public\r\n */\r\nexport function is(el, selector) {\r\n    const token = getToken(selector);\r\n    return matches(el, token.selector) && filter(el, token.filters);\r\n}\r\n\r\n/**\r\n * Find a single element based on a CSS\r\n * selector string\r\n *\r\n * @param {String} selector\r\n * @param {Element|String} root (optional)\r\n * @return {Element|Null}\r\n * @api public\r\n */\r\nexport function find(selector, root) {\r\n    return query(selector, root)[0] || null;\r\n}\r\n\r\n/**\r\n * Query for all elements matching a\r\n * CSS selector string\r\n *\r\n * @param {String} selector\r\n * @param {Element|String} root (optional)\r\n * @return {Array}\r\n * @api public\r\n */\r\nexport function query(selector, root = doc) {\r\n    if (typeof root === 'string') {\r\n        root = find(root);\r\n    }\r\n    const results = [];\r\n    const groups = selector.trim().split(groupRe);\r\n    while (groups.length) {\r\n        let context = [root];\r\n        const tokens = tokenize(groups.shift());\r\n        while (tokens.length && context.length) {\r\n            let token = tokens.shift(), combinator = combinators[' '];\r\n            if (token in combinators) {\r\n                combinator = combinators[token];\r\n                token = tokens.shift();\r\n            }\r\n            context = context.reduce((nodes, el) => combinator(el, token, nodes), []);\r\n        }\r\n        context.forEach((el) => {\r\n            if (results.indexOf(el) === -1) {\r\n                results.push(el);\r\n            }\r\n        });\r\n    }\r\n    return results.sort((a, b) => 3 - (a.compareDocumentPosition(b) & 6));\r\n}\r\n"]}